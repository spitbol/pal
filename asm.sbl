
*   Copyright 1987-2012 robert b. k. dewar and mark emmer.
*   Copyright 2012-2017 david shields

*   this file is part of macro spitbol.

*   macro spitbol is free software: you can redistribute it and/or modify
*   it under the terms of the gnu general public license as published by
*   the free software foundation, either version 2 of the license, or
*   (at your option) any later version.

*   macro spitbol is distributed in the hope that it will be useful,
*   but without any warranty; without even the implied warranty of
*   merchantability or fitness for a particular purpose.  see the
*   gnu general public license for more details.

*   you should have received a copy of the gnu general public license
*   along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*   this program takes input file in minimal token form and
*   produces assembly code for intel 80386 processor.
*   the program obtains the name of the file to be translated from the
*   command line string in host(0).  options relating to the processing
*   of comments can be changed by modifying the source.

*   in addition to the minimal token file, the program requires the
*   name of a "machine definition file" that contains code specific
*   to a particular 80386 assembler.

*   you may also specify option flags on the command line to control the
*   code generation.  the following flags are processed:
*        comments        retain full-line and end-of-line comments
*        list.comments = 1

*   the variable arch is set equal to the uppercase name of the machine
*   being processed.  specific tests upon this variable are discouraged, as
*   all machine-dependent code should be placed in the machine-definition
*   file if possible.

*   in addition to the normal minimal register complement, one scratch
*   work register, wt is defined.
*   see the register map below for specific allocations.

*   this program is based in part on earlier translators for the dec vax
*   (vms and un*x) written by steve duff and robert goldberg, and the
*   pc-spitbol translator by david shields.

*   to run under spitbol:
*        spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*   reads <file>.lex        containing tokenized source code
*   writes <file>.s         with 80386 assembly code
*   also writes <file>.err  with err and erb error messages
*   parts of <machine>.hdr  are prepended and appended to <file>.s
*   also sets flags         to 1 after converting names to upper case
*   also reads <file>.pub   for debug symbols to be declared public

*   example:

*   spitbol -u v37:dos codlinux.spt

*   revision history:

    version = 'v4.0'


*   Functions

    define('comregs(line)t,pre,word')                   :(comregs.end)

*   comregs - map minimal register names to target register names

comregs

    line p.comregs =                                    :f(comregs1)
    word = eq(size(word),2) differ(t = word) t
    comregs = comregs pre word                          :(comregs)

comregs1 comregs = comregs line                         :(return)

comregs.end


    define('crack(line)operands,operand,char')          :(crack.end)

*   crack parses stmt into a stmt data plex and returns it.
*   it fails if there is a syntax error.

*   crack is called to create a stmt plex containing the various parts  of
*   the minimal source statement in line.  for conditional assembly ops,
*   the opcode is the op, and op1 is the symbol.  note that dtc is handled
*   as a special case to assure that the decomposition is correct.

*  crack prints an error and fails if a syntax error occurs.

crack

    nstmts  = nstmts + 1
    op1 = op2 = op3 = typ1 = typ2 = typ3 =
    line    p.csparse                                   :s(return)

*  here on syntax error

    error(text)                                         :(return)

crack.end

    define('error(text)')                               :(error.end)

*   _error_ handles reporting of errors with the offending
*   statement text in thisline.  comments explaining
*   the error are written to the listing (including error chain), and
*   the appropriate counts are updated.

error

    outfile = '* *???* ' thisline
    outfile = '*       ' text
.                 (ident(lasterror),'. last error was line ' lasterror)
    lasterror = noutlines
    noutlines = noutlines + 2
    le(nerrors = nerrors + 1, 10)                       :s(return)
    output = 'too many errors, quitting'                :(end)

error.end

    define('finish()')                                  :(finish.end)


*   Complete compilation by writing out needed declarations

finish

    &dump = 0

*   here at end of code generation.  Mark end of program.

    putline('}')
    putline()
    putline('const (')

*   write out labels offsets sorted by offset value

    labels = sort(labtab,2)
    i = 0

finish.end.labels

    i = i +  1
    differ(labels<i,1>) putline(tab labels<i,1>  tab '=' tab  labels<i,2>):s(finish.end.labels)
    putline(')')


                                                        :(finish.end.const)

*   write out any real constants that need to be patched into the program text

    putline('reals = map[int] float32 {')
    drcara = sort(drctab,1)
    i = 0

finish.end.reals

    i = i + 1
    putline(tab drcara<i,1> tab ':' tab  drcara<i,2> ","):s(finish.end.reals)
    putline('}')

finish.end.const

*   write out const definitions for osint procedures

    putline('const (')
    str = osiprocs
    str break(' ') . name ' ' =
    putline(tab name '_ = iota')

finish.end.osint

    str break(' ') . name ' ' =                         :f(finish.end.osint.1)
    putline(tab name '_' )                              :(finish.end.osint)

finish.end.osint.1

    putline(')')

*   list ops used

    usedara = sort(opsused,1)
    i = 0

finish.end.ops

    nused = nused + 1
    opnam = usedara<i = i + 1,1>                        :f(finish.end.opsdone)
    opcnt = usedara<i,2>

*       output = opnam tab opcnt
*       output = tab 'case ' opnam  ':'
*       output = opnam

                                                        :(finish.end.ops)
finish.end.opsdone


*       output = 'ppm_cases'
*       putline(tab "var ppm_cases =  map[int]int {")
*   list ppm_cases

    ppm_cases_ara = sort(ppm_cases,1)
    i = 0
                                                        :(finish.end.ppm.1)

* this may not be needed

finish.end.ppm

    i = i + 1
    putline(tab  ppm_cases_ara[i,1]  tab ':' ppm_cases_ara[i,2] ','):s(finish.end.ppm)
    putline('}')

finish.end.ppm.1

*       emit error messages

    ara = sort(error_messages,1)
    i = 0
    putline('var error_messages = map[int]string {')

finish.end.11

    i = i + 1
    putline(tab ara<i,1> tab ': "' ara<i,2> '",')       :s(finish.end.11)
    putline("}")

    putline('var prc_names = map[int]string {')
    prc_ara = sort(prc_names,1)
    i = 0

finish.end.prc_names

    n = prc_ara<i = i + 1,1>                            :f(finish.end.prc_names.1)
    nam = prc_ara<i,2>
    putline(tab     +n ' : ' tab '"' nam '",')
                                                        :(finish.end.prc_names)
finish.end.prc_names.1

    putline('}')

    putline('var stmt_text = map[int]string {')
    i = 0

finish.end.stmts

    gt(i = i + 1, stmtn)                                :s(finish.end.stmts.1)
    str = stmt_text[i]                                  :f(finish.end.stmts.1)
    putline(tab i tab ':' tab '"' str '",')             :(finish.end.stmts)

finish.end.stmts.1

    putline('}')                                        :(return)

finish.end

    define('g(incode)')                                 :(g.end.g)

*   Generate code for Minimal operation _opcode_.

g

*   Branch on opcode.

                                                        :($('g.' incode))

* 1 - Basic instruction set

g.mov

    move(i1,i2)                                         :(return)

g.brn

    genop('brn',,,getarg(i1))                           :(return)

g.bsw

    genop('loadi',r1,,getarg(i2))
    genop(incode,get1(),r1,getarg(i3))                  :(return)

g.iff

    putconst(getarg(i2))                                :(return)

g.esw                                                   :(return)


g.ent

*       note that emitted constant must come before the label declaration

    putconst((differ(i.text(i1)) i.text(i1), '0'))

*       reset incode so putlab will write the label

    putlab(inlabel)
                                                        :(return)

g.bri

    genop(incode,get1())                                :(return)

g.lei

    genop(incode,i.text(i1))                            :(return)

g.jsr

    jsr_proc = getarg(i1)
    is_os = is_osint[jsr_proc]
    jsr_op = (differ(is_os) 'sys', 'call')
    genop(jsr_op,,,jsr_proc (differ(is_os) '_',''))

*       get count of following ppm statements

    jsr_count = ppm_cases[jsr_proc]
    eq(jsr_count)                                       :s(return)
    genop('jsrerr',r1,,jsr_count)
                                                        :s(return)

g.err

    error_messages[+i.text(i1)] = i.text(i2)

*       statement has no comment, so make one from the error message text

    incomment = i.text(i2)
    genop(incode,,,+i.text(i1))                         :(return)

g.ppm

    genop(incode,,,i.text(i1))                          :(return)

g.prc

    prc_names[program_counter] = inlabel
    prc.args = getarg(i2)
    ppm_cases[thislabel] = getarg(i2)
    thislabel =
    max_exi = gt(prc.args,max_exi) prc.args
    prc.type = i.text(i1)                               :($('g.prc.' prc.type))

g.prc.e
g.prc.r                                                 :(return)

g.prc.n

*   store return address in reserved location
*   the interpreter requires prc.count be nonzero for 'n' type procedures.

    prc.count = prc.count + 1
    genop('prc',,,prc.count)
                                                        :(return)

g.exi

*   TODO: multiply by 100 if prc type 'n'

    exitn = (ident(i1) 0, +i.text(i1))
    exitn = ident(prc.type,'n') 100 * prc.count + exitn
    genop(incode,,,exitn)                               :(return)

g.enp                                                   :(return)

g.erb

    error_messages[+i.text(i1)] = i.text(i2)
    genop('erb',,,+i.text(i1))                          :(return)

g.start

g.icv
    genop('icv',get1())
    put1()                                              :(return)

g.dcv
    genop('dcv',get1())
    put1()                                              :(return)

g.zer
g.mnz

    zer.reg = (ident(incode, 'zer') r0, xs)
    move(i1,minarg(8,zer.reg))
                                                        :(return)

g.rtn
g.ssl
g.sss
                                                        :(return)

* 2 - Operations on one word integer values (addresses)

g.add

    genop('add',get1(),get2())
    put1()                                              :(return)

g.sub

    genop('sub',get1(),get2())
    put1()                                              :(return)

g.ica

* result may need to be stored back to memory

    genop('ica',get1())
    put1()
                                                        :(return)

g.dca

* result may need to be stored back to memory

    genop('dca',get1())
    put1()                                              :(return)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi

    genop(incode,get1(),get2(),getarg(i3))              :(return)

g.bod
g.bev
g.bnz
g.bze

    genop(incode,get1(),,getarg(i2))                    :(return)

g.lct

    ident(i.text(i1),i.text(i2))                        :s(return)
    move(i1,i2)                                         :(return)

g.lct.1

    genop('mov',get1(),get2())                          :(return)

g.bct

    genop('bct',getarg(i1),,getarg(i2))                 :(return)

g.aov

*   result may need to be stored back to memory
*   TODO: results are in wrong order in minimal code (need to fix)
*   so put second argument first in generated pseudo-code

    genop(incode,get2(),get1(),getoff(i3))              :(return)

* 3 - Operations on the code pointer register (CP)

g.lcp
g.lcw
g.scp
                                                        :(g.one)

g.icp
                                                        :(g.none)

* 4 - Operatons on signed integer values

g.ldi
g.adi
g.mli
g.sbi
g.dvi
g.rmi
                                                        :(g.one)

g.ngi                                                   :(g.none)

g.sti
    move(i1,arg.ia)                                     :(return)

g.ino
g.iov
    genop(incode,,,getarg(i1))                          :(return)

g.ieq
g.ige
g.igt
g.ile
g.ilt
g.ine
    genop(incode,,,getarg(i1))                          :(return)

* 5 - Operations on real values

g.ldr
g.adr
g.sbr
g.mlr
g.dvr
                                                        :(g.one)

g.str move(i1,ra.arg)                                   :(return)

g.ngr                                                   :(g.none)

g.atn
g.chp
g.cos
g.etx
g.lnf
g.sin
g.sqr
g.tan

    genop('realop',,,incode)
                                                        :(return)

g.rno
g.rov
g.req
g.rne
g.rge
g.rgt
g.rle
g.rlt

    genop(incode,,,getoff(i1))
                                                        :(return)

* 6 - Operations on character values

g.plc
g.psc

    genop(incode,get1(),get2())                         :(return)

g.lch

    move(i1,i2)                                         :(return)

g.sch

    move(i2,i1)                                         :(return)

g.csc                                                   :(return)

g.ceq
g.cne

    genop(incode,get1(),get2(),getarg(i3))              :(return)

g.cmc

    genop('loadi',r1,getarg(i1))
    genop('loadi',r2,getarg(i2))
    genop('cmc')                                        :(return)

g.trc

    genop(incode)                                       :(return)

g.flc

    genop(incode,get1())                                :(return)

* 7 - Operations on bit string values

g.anb
g.orb
g.xob
                                                        :(g.two)

g.rsh
g.lsh

    genop(incode,getarg(i1),,getarg(i2))                :(return)

g.cmb

    genop(incode,getarg(i1))                            :(return)

g.rsx

    error('rsx not supported')                          :(return)

g.lsx

    error('lsx not supported')                          :(return)

g.nzb
g.zrb

    genop(incode,get1(),,getarg(i2))                    :(return)

g.zgb                                                   :(return)

* 8 - Conversion instructions

g.wtb                                                   :(return)

g.btw                                                   :(return)

g.mti
    move(arg.ia,i1)                                     :(return)

g.mfi

    move(i1,arg.ia)

*   last arg is optional

    eq(i.type(i2))                                      :s(g.mfi.1)

*   compare with cfp$m, branching if result negative
*   here if label given, branch if ia not in range (ie, negative)

    genop(incode,,,getoff(i2))

g.mfi.1
                                                        :(return)

g.itr

    genop(incode)                                       :(return)

g.rti

*  here if label given, branch if real too large

   genop(incode,,,getarg(i1))                           :(return)

g.ctw
g.ctb

*       output = incode ' ' i.text(i1) ' ' i.text(i2)

    ident(getarg(i2),'0')                               :s(return)
    genop(incode,getarg(i1),,getarg(i2))                :(return)

g.cvm

    genop(incode,,,getarg(i1))                          :(return)

g.cvd                                                   :(g.none)

* 9 - BLock move instructions

g.mvc
g.mcb
g.mvw
g.mwb
                                                        :(g.none)

* 10 - Operations connected with the stack

g.chk                                                   :(g.none)

    genop('cmp',xs,,'lowspmin')
    genop('jb',,,'sec06')
                                                        :(return)

* 11 - Data generation instructions

g.dac
g.dbc
g.dic

    putconst(getarg(i1))                                :(return)

g.drc

    str = i.text(i1)
*       strip leading +
    str '+' =
    drctab<program_counter> = i.text(i1)
    putconst("0")
                                                        :(return)

g.dtc

*   each character needs separate declaration, but do not include enclosing '/' characters

*       putline('dtc ' i.text(i1))

    differ(thislabel) putlab(thislabel)
    str = i.text(i1)
    str = substr(str,2,size(str) - 2)

g.dtc.1

    str len(1) . c =                                    :f(return)
    putconst("'" c "'")                                 :(g.dtc.1)


* 12 - Symbol definition instructions

g.equ

    putline(tab thislabel ' = ' i.text(i1))
                                                        :(return)
g.exp

    ppm_cases[thislabel] = i.text(i1)
*       putline('//' tab 'extern' tab thislabel)
    thislabel =                                         :(return)

g.inp

    ppm_cases[thislabel] = i.text(i2)
    prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+                                                       :(return)

g.inr

    putline('//' tab incode tab thislabel)              :(return)

* 13 - Assembly listing layout instruction

g.ejc
g.ttl


                                                        :(return)

* 14 - Program form

g.sec

    sectnow = sectnow + 1                               :($("g.sec." sectnow))

*   procedure declaration section

g.sec.1

*   write out opcode definitions

    putline('const (')
    putline(tab     'nop = iota')
    opcodea = sort(opcodes,1)
    i = 0

*   write out opcodes offsets sorted by offset value

    opcodea = sort(opcodes,1)
    i = 0

g.sec.1.2

    i = i +  1

*       differ(opcodea<i,1>) putline(tab opcodea<i,1>  tab '=' tab  opcodea<i,2>)       :s(g.sec.1.2)

    putline(tab opcodea<i,1>)                           :s(g.sec.1.2)
    putline(')')

g.sec.1.1

    putline('//sec01')
                                                        :(return)

*   definitions section

g.sec.2

    putline('const (')
                                                        :(return)

*   constants section

g.sec.3

    putline(tab ')')
    putline('//sec03')
    putline('var program = []int {')

*   emit single word so program counter will start at one.

    putline(tab "0,")
    program_counter = 1
                                                        :(return)

*   working variables section
g.sec.4

    putline('//sec04' )                                 :(return)

*   here at start of program section.  if any n type procedures,
*   put out entry-word block declaration at end of working storage

g.sec.5

    in_executable = 1

*   emit code to indicate in code section
*   get direction set to up.

*TODO   genop('prc_: times ' prc.count1 ' dd 0') putline('// sec05' )

                                                        :(return)

*  stack overflow section.  output exi__n tail code

g.sec.6

    putlab('sec06')                                     :(return)

*  error section.  produce code to receive erb's

g.sec.7

    putline('//sec07' )

*   since 'error' is a keyword, emit label 'error_' for use in generating err instruction

    putlab('error_')
                                                        :(return)

g.end

                                                        :(return)

*   These utility procedures are used to just map Minimal opcode and
*   its arguments into the same target opcode.

g.none

    genop(incode)                                       :(return)

g.one
    genop(incode,get1())
                                                        :(return)
g.two

*       putline("// g.two " incode " " i.text(i1) "," i.text(i2))

    genop(incode,get1(),get2())
                                                        :(return)

g.oneput

*   here for standard case with single argument which is computed
*   and so must be stored back if it came from memory

of

    ifreg(i1)                                           :f(g.oneput.1)

*   here if argument is register, so just use it

    genop(incode,getreg(i1))                            :(return)

g.oneput.1

* here if argument in memory. First bring it to r1

    oneput.arg = i1

* then do the operation

    oneput.res = get1()
    genop(incode,oneput.res)

*   and now store it back

    genop('store',oneput.res,oneput.reg.oneput.off)     :(return)

g.twoput

*   here for standard case with two arguments

    genop(incode,get1(),get2())
    differ(get1.mem) put1('r1',get1.mem)
                                                        :(return)


g.end.g

    define('genlab()')                                  :(genlab.end)

*  generate unique labels for use in generated code

genlab

   genlab = 'labl' lpad(genlabels = genlabels + 1,3,'0'):(return)

genlab.end

    define('genop(gopc,gop1,gop2,gop3,gcom)')           :(genop.end)

*  generate operation

genop

    opsused[gopc] = opsused[gopc] + 1
    putstmt(gopc,gop1,gop2,gop3,gcom)                   :(return)

genop.end


    define('get1()')                                    :(get1.end)

*   return argument if it is a register, or else load the argument
*   value into r1

get1

    ident(i.text(i1))                                   :s(return)
    ifreg(i1)                                           :f(get1.1)
    get1 = getreg(i1)                                   :(return)

get1.1

    move(arg.r1,i1)
    get1 = r1                                           :(return)

get1.end

    define('get2()')                                    :(get2.end)

*   return register if i2 is register, else load i2 value to r2

get2

    ident(i.text(i2))                                   :s(return)
    ifreg(i2)                                           :f(get2.1)
    get2 = getreg(i2)                                   :(return)

get2.1

    move(arg.r2,i2)
    get2 = r2                                           :(return)

get2.end

    define('getarg(iarg,imem)l1,l2,t1,t2')              :(getarg.end)

getarg

    l1 = i.text(iarg)
    l2 = i.type(iarg)
    eq(l2)                                              :f($(getargcase[l2]))
    getarg = l1                                         :(return)

*   int

getarg.c.1

    getarg = l1                                         :(return)

*   dlbl

getarg.c.2

    getarg = l1                                         :(return)

*   wlbl, clbl

getarg.c.3

getarg.c.4

    getarg =  l1                                        :(return)

*   elbl, plbl

getarg.c.5
getarg.c.6

*   cannot use 'error' as label since it is go keyword

    l1 = ident(l1,'error') 'error_'
    getarg = l1                                         :(return)

*   w,x, map register name

getarg.c.7
getarg.c.8

    getarg = $l1                                        :(return)

*   (x), register indirect

getarg.c.9

    l1 len(1) len(2) . l2
    l2 = $l2
    getarg =  l2                                        :(return)

*   (x)+, register indirect, post increment

getarg.c.10

    l1 = substr(l1,2,2)
    t1 = $l1
    getarg =  t1
                                                        :(return)

*  -(x), register indirect, pre decrement

getarg.c.11

    t1 = $substr(l1,3,2)
    getarg =  t1
                                                        :(return)

*   int(x)
*   dlbl(x)

getarg.c.12
getarg.c.13

    l1 break('(') . t1 '(' len(2) . t2
    getarg =  $t2 '!' t1                                :(return)

*   name(x), where name is in working section

getarg.c.14
getarg.c.15

    l1 break('(') . t1 '(' len(2) . t2
    getarg = $t2 '!' t1                                 :(return)

*   signed integer

getarg.c.16

    getarg = l1                                         :(return)

*   signed real

getarg.c.17

    getarg = l1                                         :(return)

*   =dlbl

getarg.c.18

    getarg = substr(l1,2)                               :(return)

*   *dlbl

getarg.c.19

    getarg = substr(l1,2)                               :(return)

*   =name (data section)

getarg.c.20
getarg.c.21

    getarg =  substr(l1,2)                              :(return)

*   =name (program section)

getarg.c.22

    getarg =  substr(l1,2)                              :(return)

*   pnam, eqop

getarg.c.23
getarg.c.24

    getarg = l1                                         :(return)

*   ptyp, text, dtext

getarg.c.25
getarg.c.26
getarg.c.27

    getarg = l1                                         :(return)

getarg.end

    define('getoff(iarg)itext,itype')                   :(getoff.end)

*   return offset of argument, or 0

getoff

    itype = i.type(iarg)
    itext = i.text(iarg)
    lt(itype,2)                                         :s(return)
    gt(itype,6)                                         :s(getoff.1)

*   here if plain label, just return it

    getoff = itext                                      :(return)

getoff.1

    lt(itype,12)                                        :s(return)
    gt(itype,15)                                        :s(getoff.2)
    i.text(iarg) break('(') . getoff                    :(return)

getoff.2

    gt(itype,22)                                        :s(return)
    getoff = substr(itext,2)                            :(return)

getoff.end

    define('getreg(iarg)atype')                         :(getreg.end)

*   return register associated with argument, or r0 if no register
*   since it is assumed a register is needed.

getreg

*   assume result is r0

    getreg = r0
    atype = i.type(iarg)
    lt(atype,6)                                         :s(return)
    gt(atype,8)                                         :s(getreg.1)

*   here if explicit x or w register

    getreg = i.text(iarg)                               :(return)

getreg.1

    gt(atype,15)                                        :s(getreg.2)

*   here if register enclosed in parentheses
    i.text(iarg) break('(') '('  len(2) . getreg
    getreg = getreg
                                                        :(return)
getreg.2

*   no type if numeric constant

    le(atype,17)                                        :s(return)
    gt(atype,22)                                        :s(return)

*   here if literal, so return r0

    getreg = r0                                         :(return)

getreg.end

    define('iflit(iarg)')                               :(iflit.end)

    iflit(iarg) - test if argument is literal

iflit

    ge(i.type(iarg),18) le(i.type(iarg),22)             :f(freturn)s(return)


iflit.end

    define('ifmem(iarg)')                               :(ifmem.end)

ifmem

    ge(i.type(iarg),3) lt(i.type(iarg),6)               :s(return)
    ge(i.type(iarg),9) le(i.type(iarg),15)              :s(return)f(freturn)

ifmem.end

    define('ifpost(iarg)')                              :(ifpost.end)
ifpost

    eq(i.type(iarg),10)                                 :s(return)f(freturn)

ifpost.end

    define('ifpre(iarg)')                               :(ifpre.end)

ifpre

    eq(i.type(iarg),11)                                 :s(return)f(freturn)

ifpre.end

    define('ifreg(iarg)')                               :(ifreg.end)

ifreg

*       ia is considered to be a register

    eq(i.type(iarg),8) ident(i.text(iarg),'ia')         :s(return)
    ge(i.type(iarg),7) le(i.type(iarg),8)               :f(freturn)s(return)

ifreg.end


    define('init()')                                    :(init.end)

*   Initialize global variables.

init

*   keyword initialization


    &anchor = 1;    &stlimit = 10000000;    &trim   = 1;  &dump = 1

*  useful constants

    digits = '012356789'
    letters = 'abcdefghijklmnopqrstuvwxyz'
    ucase  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lcase   = letters
    nos     = '0123456789'
    tab     = char(9)

    fileprefix = "s"

*   1 is bytes per word, 1 is characters per word
*   these should agree with values used in translator
*   set target-dependent configuration parameters

*   op_w is instruction suffix for word-size

    op_w = ''
*       op_c is instruction suffix for minimal character size
    op_c = ''

    stmt_text = table(15000)

    data('minarg(i.type,i.text)')

    sectnow = 0

*   ppm_cases gives count of ppm/err statments that must follow call to a procedure

    ppm_cases = table(50,,0)

*   prc_names maps program_counter values to name of program entry point

    prc_names = table(100)

    error_messages = table(200)

*   is_exec identifies the executable minimal statements

    is_exec = setini(
.       'flc add adi adr anb aov atn '
.       'bod bev bct beq bge bgt '
.       'bhi ble blo blt bne bnz brn '
.       'bri bsw bsw btw bze ceq '
.       'chk chp cmb cmc cne cos csc ctb '
.       'ctw cvd cvm dac dbc dca dcv '
.       'dvi dvr erb etx exi exp '
.       'ica icp icv ieq ige igt ile ilt ine ino '
.       'iov itr jsr lch lct lcp '
.       'lcw ldi ldr lei lnf lsh lsx mcb '
.       'mfi mli mlr mnz mov mti '
.       'mvc mvw mwb ngi ngr nzb '
.       'orb plc prc prc psc req '
.       'rge rgt rle rlt rmi rne rno '
.       'rov rsh rsx rti rtn sbi '
.       'sbr sch scp sec sin sqr ssl sss '
.       'sti str sub trc '
.       'wtb xob zer zgb zrb ')

    p.comregs = break(letters) . pre span(letters) . word

*   exttab has entry for external procedures

    exttab = table(50)

*   labtab records labels and their offsets in the program section

    labtab = table(500)

*   genlabels is count of generated labels (cf. genlab)

    genlabels = 0

*   initialize variables

    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0

*   initial patterns

*   p.csparse parses tokenized line

    p.csparse = '{' break('{') . inlabel
.       '{' break('{') . incode
.       '{' break('{') . iarg1
.       '{' break('{') . iarg2
.       '{' break('{') . iarg3
.       '{' break('{') . incomment
    '{' rem . slineno

*   dispatch table

    getargcase = table(27)
    getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
    getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
    getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
    getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
    getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
    getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
    getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
    getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
    getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
    getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
    getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
    getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
    getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
    getargcase[27] = .getarg.c.27

    opcodes = table(100)
    s =
+       'add adi adr anb aov atn '
+       'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze call ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr enp err erb esw etx exi flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr jsrerr lch lct lcp lcw ldi ldr lei loadi loadcfp lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvc mvw mwb ngi eti ngr nzb orb plc ppm prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti stmt str sub sys tan trc wtb xob zer '
+       'ent inr lea move load loadi push pushi pushr pop popr realop store zrb '

*       don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

    opsused = table(100)

init.opcodes.1

    s break(' ') . opc ' ' =                            :f(init.opcodes.2)
    opcodes[opc] = 1                                    :(init.opcodes.1)

init.opcodes.2

*   since program is represented as an array of unsigned integers we cannot
*   enter real constants, so we create a map that can be used to enter the values later.

    drctab = table(50)

    osiprocs =
.       'sysax sysbs sysbx syscm sysdc sysdm sysdt sysea sysef sysej sysem sysen sysep sysex '
.       'sysfc sysgc syshs sysid sysif sysil sysin sysio sysld sysmm sysmx sysou syspi syspl '
.       'syspp syspr sysrd sysri sysrw sysst systt systm sysul sysxi '

*   initialize osint procs

    is_osint = setini(osiprocs)



*   get definition file name following token file name, and flags.

*       fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+              ((len(1) rem . flags) | '')
*       $replace(target,lcase,ucase) = 1

* parse and display flags, setting each one's name to non-null value (1).

                                                        :(init.flgs.skip)

init.flgs       flags ? ((len(1) break(';               :')) . flag len(1)) |
+        ((len(1) rem) . flag) =                        :f(init.flgs2)
    flag = replace(flag,lcase,ucase)
    output = "  flag  " flag
    $flag = 1                                           :(init.flgs)

init.flgs.skip
init.flgs2

*   We use three additional registers in addition to the minimal registers

*   r0      is always zero
*   r1      is used to load the value of the first operand if it is in memory
*   r2      is used to load the value of the second operand if it is in memory

    r0 = 'r0'; r1 = 'r1'; r2 = 'r2'
    xl = 'xl'; xr = 'xr'; xs = 'xs'; xt = 'xl'
    wa = 'wa'; wb = 'wb'; wc = 'wc'
    ia = 'ia'; cp = 'cp'; ra = 'ra'

    r1 = 'r1'
    r2 = 'r2'
    arg.r1 = minarg(8, 'r1')
    arg.r2 = minarg(8, 'r2')
    arg.ia = minarg(8, 'iA')
    ra.arg = minarg(8, 'rA')

    r0 = 'r0'; r1 = 'r1'; r2 = 'r2'
    xl = 'xl'; xr = 'xr'; xs = 'xs'; xt = 'xl'
    wa = 'wa'; wb = 'wb'; wc = 'wc'

    r1 = 'r1'
    r2 = 'r2'

    arg.r1 = minarg(8, 'r1')
    arg.r2 = minarg(8, 'r2')
    arg.ia = minarg(8, 'ia')
    ra.arg = minarg(8, 'ra')

*   operation encoding

*   Each generated operation has four fields:

*   opc - opcode
*   dst - destination register
*   src - source register
*   off - offset, either immediate constant or address

*   Memory references always use the src and off registers.
*   The effective address is obtained by adding the offset to the contents of the
*   src register. If the src register is r0, the the effective address is the offset.

    filenami = fileprefix '.lex'
    input(.infile,1,filenami)                           :s(init.input)
    error('cannot open input file [' filenami ']')      :(end)

init.input

*   associate output file.

    filenamo = fileprefix '.go'
    output(.outfile,2,filenamo)                         :s(init.output)
    output = '  cannot open asm file: ' filenamo        :(end)

init.output
                                                        :(return)

init.end

    define('move(dst,src)dtype,stype,mop,stext,dtext')  :(move.end)

move

*   generate code for move instruction
*   move is translated to one of more of the following

*   dst and src indicate registers (either w or x register, or r0, which is always zero)
*   lab indicates proram label
*   lit is program literal

*   Cases where destination is a register
*   mov  dst,src
*               move    dst,src
*   mov dst,(src)
*               load    dst,src
*   mov dst,off(src)
*               load    dst,src,off
*   mov dst,(src)+
*               load    dst,src,0
*               ica     src
*   mov dst,-(src)
*               dca     src
*               load    dst,src,0
*   mov dst,lab
*               load    dst,r0,lab
*   mov dst,lit
*               loadi   dst,r0,lit

*   if target is not a register and the source is not in a register,
*   then the source operand is loaded to a register.
*   the remaining cases are:

*   mov (x)+,reg
*               store   reg,x,0
*               ica     x
* mov   -(x),reg
*               dca     x
*               store   reg,x,0
* mov   lab,reg
*               store   reg,r0,lab
* mov   (x),reg
*               store   reg,x,0
*

*   The src and off fields are always used to refer to an operand in memory

    stype = i.type(src); stext = i.text(src)
    dtype = i.type(dst); dtext = i.text(dst)
    ifreg(dst) ifreg(src)                               :s(move.reg.reg)
    ifreg(dst) ifpost(src)                              :s(move.reg.post)
    ifreg(dst) ifpre(src)                               :s(move.reg.pre)
    ifreg(dst) iflit(src)                               :s(move.reg.lit)
    ifreg(dst) ifmem(src)                               :s(move.reg.mem)

*   remaining cases are
*       mov     dst,(src)
*       mov     dst,off(src)
*       mov     dst,lab

***     ifreg(dst) ifmem(src)                   :s(move.dst.mem)

*   here if target not register and source is not in a register

    ifpost(dst) ifreg(src)                              :s(move.post.reg)
    ifpre(dst) ifreg(src)                               :s(move.pre.reg)
    ifmem(dst) ifreg(src)                               :s(move.mem.reg)

*   here if dst and src both in memory, so move src to r1 and then do store
*       output = 'memory to memory'
*       output = 'move ' program_counter ' ' dtype ' ' dtext '  ' stype ' ' stext
*.      (ifreg(dst) ' DR','') (ifmem(dst) ' DM', '')
*.      (ifreg(src) ' SR','') (ifmem(src) ' SM','')
    move(arg.r1,src)
    move(dst,arg.r1)                                    :(return)
    error('impossible move case')                       :(return)

move.reg.reg

    genop('move',getreg(dst),getreg(src))               :(return)

move.reg.post

    genop('load',getreg(dst),getreg(src))
    genop('ica',getreg(src))                            :(return)

move.reg.pre

    genop('dca',getreg(src))
    genop('load',getreg(dst),getreg(src))
                                                        :(return)
move.reg.lit

    off = getoff(src)
    differ(off,'cfp_m')                                 :s(move.reg.lit.1)
    genop('loadcfp',getreg(dst))                        :(return)

move.reg.lit.1

*   special case cfp_m since it won't fit into offset field of loadi instruction.

    genop('loadi',getreg(dst),,getoff(src))             :(return)

move.reg.mem

    genop('load',getreg(dst),getreg(src),getoff(src))   :(return)

move.post.reg

    genop('store',getreg(src),getreg(dst))
    genop('ica',getreg(dst))
                                                        :(return)
move.pre.reg

    genop('dca',getreg(dst))
    genop('store',getreg(src),getreg(dst))
                                                        :(return)

move.mem.reg

    genop('store',getreg(src),getreg(dst),getoff(dst))
                                                        :(return)

move.end

    define('out(text1,text2,text3)type1,type2')         :(out.end)

*   _Out_ writes a line to standard output  conisting of _text1_,
*   then _text2_ enclosed in brackets if _text2_ is not null, followed
*   by _text3_ if _text3_ is not null.

out

    output  = text1 (differ(text2) '[' text2 ']', '') (differ(text3) text3,''):(return)

out.end

    define('prcent(n)')                                 :(prcent.end)

prcent

    prcent = 'prc_' '+'  (1 * ( n - 1))                 :(return)

prcent.end

    define('putconst(value)')                           :(putconst.end)

putconst

    putstmt(value)                                      :(return)

putconst.end

    define('putlab(label)')                             :(putlab.end)

putlab

*       ident(incode,'ent')                             :s(return)

    ident(label)                                        :s(return)

*   avoid use of go keyword as label

    label = ident(label,'error') 'error_'
    labtab<label> = program_counter

*       putline('// ' label ' - ' +program_counter )    :(return)

    putline('// ' label ':')                            :(return)

putlab.end

    define('putstmt(opcode,op1,op2,op3,comment)')       :(putstmt.end)

putstmt

*   If no opcode, then return immediately.

*   out('putstmt',opcode)
*   differ(op1) out('putstmt op1',op1)
*   differ(op2) out('putstmt op2',op2)
*   differ(op3) out('putstmt op3',op3)

*   eq(program_counter,2658) putline('HAVE IT')
    op2 = ident(op2,r0) ''
    stmtout =
.       "/* " lpad(program_counter,5) " */"
.       tab rpad(opcode,8)
.       (differ(op1) '| ' rpad(op1,6)  ' << dst_ ',)
.       (differ(op2) '| ' rpad(op2,6)  ' << src_ ',)
.       (differ(op3) '| ' rpad(op3,6)  ' << off_ ',)
.       ','
.       (differ(comment) tab comment,)
    op = op1 = op2 = op3 =
    ident(list.comments)                                :s(putstmt.op)
    ident(incomment)                                    :s(putstmt.op)
    stmtout = rpad(stmtout,60) '// ' incomment

putstmt.done

*       reset incomment since single minimal statement may generate more than one target statement

    incomment =

putstmt.op

    stmtout = trim(stmtout)
    ident(stmtout)                                      :s(return)
    program_counter = program_counter + 1
    putline(stmtout)
                                                        :(return)

putstmt.end

    define('prsarg(iarg)l1,l2')                         :(prsarg.end)

prsarg

    prsarg = minarg(0)
    iarg break(',') . l1 ',' rem . l2                   :f(return)
    prsarg = minarg(convert(l1,'integer'),l2)           :(return)

prsarg.end


    define('put1()')                                    :(put1.end)
put1

*       store updated value of i1 is memory reference

    ifreg(i1)                                           :s(return)
    move(i1,arg.r1)                                     :(return)

put1.end

    define('putline(line)')                             :(putline.end)

putline

    outfile = line
    ntarget = ntarget + 1
    noutlines = noutlines + 1                           :(return)

putline.end

    define('readline()')                                :(readline.end)

*   readline is called to return the next non-comment line from
*   the minimal input file (infile <=> lu1).   note that it will
*   not fail on eof, but it will return a minimal end statement

*   this routine returns the next statement line in the input file
*   to the caller.  it never fails.  if there is no more input,
*   then a minimal end statement is returned.
*   comments are passed through to the output file directly.


readline

    readline = infile                                   :f(readline.eof)
    nlines  = nlines + 1
    ident( readline )                                   :s(readline)

*   Ignore comments for now.
*   differ(list.comments) putline('//' substr(readline,2))

    leq(substr(readline,1,1 ),'*')                      :s(readline)

                                                        :(return)
readline.eof

    readline = '       end'                             :(return)

readline.end

    define('report(num,text)')                          :(report.end)

report
    output = lpad(num,10) '  ' text                     :(return)

report.end

    define('setini(str)elmt')                           :(setini.end)

*   this routine builds a set as a map from a string of elements

setini

    setini = table(100)

setini.1

    str break(' ') . elmt ' ' =                         :f(return)
    setini[elmt] = 1                                    :(setini.1)

setini.end

    define('tblini(str)pos,cnt,index,val,lastval')      :(tblini.end)

*   this routine is called to initialize a table from a string of
*   index/value pairs.

tblini   pos     = 0

*   count the number of "[" symbols to get an assessment of the table
*   size we need.

tblini.1

    str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.                                                       :s(tblini.1)

*   allocate the table, and then fill it. note that a small memory
*   optimisation is attempted here by trying to re-use the previous
*   value string if it is the same as the present one.

    tblini   = table(cnt)

tblini.2

    str (break('[') $ index len(1) break(']') $ val len(1)) =:f(return)
    val = convert( val,'integer' )
    val = ident(val,lastval) lastval
    lastval = val
    tblini[index] = val                                 :(tblini.2)

tblini.end

    define('translate()')                               :(translate.end)

*   Main Program

translate

    outfile = 'package main'

*   start translation

*   The main loop reads the next input line, skipping comments, processes
*   the statment label if present, and calls g() to translate the Minimal instruction.

translate.next

    label = thislabel =
    thisline = readline()
    crack(thisline)                                     :f(translate.next)
    thislabel = inlabel
    lt(sectnow,3)                                       :s(translate.label)
    ident(inlabel)                                      :s(translate.label)

*   need to defer label generation in case of 'ent' operator

    differ(incode,'ent')    putlab(inlabel)

*   need to defer label generate for 'ent' operator
*   differ(incode,'ent')    putlab(inlabel)

    label = thislabel =

translate.label

    i1 = prsarg(iarg1)
    i2 = prsarg(iarg2)
    i3 = prsarg(iarg3)

    tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.               i.text(i2) ' ' i.text(i3)
    argerrs = 0
    ident(in_executable)                                :s(translate.op)
    ident(is_exec[incode])                              :s(translate.op)

    untext = unlex(thisline)
    stmt_text[stmtn = stmtn + 1] = untext

*   only emit 'stmt' to trace executable statements
*   cannot emit 'stmt' opcode when in midst of compiling 'bsw' statement

    genop('stmt',,,stmtn,untext)

translate.op

*   out('OP',incode)
    g(incode)                                           :f(freturn)
    differ(incode,'end')                                :s(translate.next)
                                                        :(return)
                                                        

translate.end

    define('unlex(text)ulab,uop,u1,u2,u3,ucom,inum')    :(unlex.end)

unlex

    unlex = text
    unlex  '{' break('{') . ulab '{' break('{') . uop
.               '{' break('{') . u1 '{' break('{') . u2
.               '{' break('{') . u3 '{' break('{') . ucom
.               '{' rem . unum
            u1 span(digits) ',' =
            u2 span(digits) ',' =
            u3 span(digits) ',' =
    unlex =  '//' (ident(ulab) tab, ulab tab)  uop ' ' u1 ' ' u2 ' ' u3 ' ' ucom
                                                        :(return)

unlex.end

*   Main program

    init()
    translate()
    finish()

*   Close files and issue summary report

    endfile(1)
    endfile(2)

    output  = '  ' gt(prc.count,prc.count1)
.         '  differing counts for n-procedures          :'
.         ' inp ' prc.count1 ' prc ' prc.count
    ne(nerrors) report(nerrors,'errors detected')

end

